# LeetCode01 两数之和
题目描述

给定一个整数数组 nums 和一个目标值
target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

![image](https://github.com/2018uestc/LeetCode_tupian/blob/master/LeetCode01.png)

解题思路：

这个题目第一眼一看首先想到的是暴力解决，采用2重循环，类似于双指针的解法，结果是可以通过的，具体代码如下：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

对于上面暴力解法，时间复杂度为O(n^2)，空间复杂度为O(1)一般在算法题里面是会超时的。如何不采用暴力解法。对于该题可以采用哈希来解决。哈希的作用就是用空间换时间。我们遍历原数组，hash里面存放的是数组中的元素和对应下标的值。遍历一遍即可，具体代码如下：

```java
class Solution{
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int complement=target-nums[i];
            if(map.containsKey(complement)){
                return new int[]{map.get(complement),i};
            }
            map.put(nums[i],i);
        }
        throw new IllegaArgumentException("没有满足条件的结果");
    }
}
```
这种解法的时间复杂度为O(n)，空间复杂度为O(n)。典型的空间换时间的算法。

# LeetCode04 寻找两个有序数组的中位数
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。  
示例 1:  
nums1 = [1, 3]
nums2 = [2]  
则中位数是 2.0  
示例 1:  
nums1 = [1, 2]
nums2 = [3,4]  
则中位数是 (2 + 3)/2 = 2.5

解题思路 
1. 第一眼看到这个题目的时候，首先想到的是将给定的2个数组合并成一个数组，然后求一个数组的中位数的，一个数组的中位数对于我们来说很熟悉。但是题目中明确要求时间复杂度为O(log(m + n))，这就给之前的那个单纯的想法判了死刑。但是同时也打开了另外一扇窗，就是这个时间复杂度很明显是二分差查找法的特征。因此想到用二分法来解决。  
1. 那么这个二分法究竟怎么来解决这个题目呢？首先我们定义nums1和nums2的长度分别为m和n，如果m+n为奇数，那么中位数为numCombination[(m+n)/2 + 1]，加1的原因是下标和第几个元素之间相差1。如果m+n为偶数，那么中位数为numCombination[(m+n)/2 + 1]+numCombination[(m+n)/2]相加除以2。以上numCombination指的是nums1和nums2合并后的数组，用作分析用。  
1. 所以本题目变成了两个有序数组A(m), B(n)，k = (m+n)/2，奇数时找k+1大的数，偶数是找第k大和第k+1大的数再除2（依然是数组中的第几个，和下标相差1）。即题目转换成了求2个有序数组中的第k大数。可以采用二分查找的方法。  
1. 找第k((m+n)/2)大的数。先在A，B中分别找第k/2大的数，如果A[k/2-1]等于B[k/2-1]，那么这个数就是两个数组中第k大的数。如果A[k/2-1]<B[k/2-1],那么说明A[0]到A[k/2-1]都不可能是第k大的数，所以需要舍弃这k/2，继续从A[k/2]到A[A.length-1]继续找。当然，因为这里舍弃了A[0]到A[k/2-1]这k/2个数，那么第k大也就变成了第k-k/2个大的数了。如果 A[k/2-1]>B[k/2-1]，那么说明B[0]到B[k/2-1]都不可能是第k大的数，舍弃这k/2。如此迭代或者递归操作，如果有一个数组为空了，则返回另一个数组的第k大(剩下需要二分长度)的数。如果k==1，只需返回此时所以数中排第一小的数，就返回此时A，B中第一个元素小的那个。代码如下：
 
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m=nums1.length;
        int n=nums2.length;
        int len=m+n;
        //奇数查len+1
        if(len%2==1){
            return findKth(nums1,0,nums2,0,len/2+1);
        }
        //偶数查
        return (findKth(nums1,0,nums2,0,len/2)+findKth(nums1,0,nums2,0,len/2+1))/2.0;
    }
    public static int findKth(int[] A, int A_start,
                              int[] B, int B_start,
                              int k){
        //A_start>= A.length，说明第k个数不在数组A当中，所以要去数组B中去找                      
        if (A_start >= A.length) {
            return B[B_start + k - 1];
        }
        //B_start>= B.length，说明第k个数不在数组B当中，所以要去数组A中去找
        if (B_start >= B.length) {
            return A[A_start + k - 1];
        }
        if (k == 1) {
            return Math.min(A[A_start], B[B_start]);
        }
         
        int A_key = A_start + k / 2 - 1 < A.length
                    ? A[A_start + k / 2 - 1]
                    : Integer.MAX_VALUE;
        int B_key = B_start + k / 2 - 1 < B.length
                    ? B[B_start + k / 2 - 1]
                    : Integer.MAX_VALUE;
         
        if (A_key < B_key) {
            return findKth(A, A_start + k / 2, B, B_start, k - k / 2);
        } else {
            return findKth(A, A_start, B, B_start + k / 2, k - k / 2);
        }
    }
}
```
## # LeetCode11 盛最多水的容器  
题目描述  
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 n 的值至少为 2。 
![image](https://img-blog.csdnimg.cn/20191204095741272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTUwMzI4,size_16,color_FFFFFF,t_70)
示例:  
输入: [1,8,6,2,5,4,8,3,7]  
输出: 49  
解题思路1：  
刚刚看到这个题目的时候想到过一个原理-木桶原理。一个木桶里面是否可以装水取决于最薄的那块板子。换做这个题目就是木桶可以装多少水取决于最短的那块板子。我们首先想到的是暴力解法，单纯的暴力枚举所有的可能出现的线段组合下的最大面积。java代码如下：

```java
class Solution{
    public int maxArea(int[] height) {
        if(height==null || height.length<2) return 0;
        int maxArea=0;
        for(int i=0;i<height.length-1;i++){
            for(int j=i+1;j<height.length;j++){
                maxArea=Math.max(maxArea,Math.min(height[i],height[j])*(j-i));
            }
        }
        return maxArea;
    }
}
```
暴力解法有2重循环，时间复杂度为O（n^2），空间复杂度为O（1）。  

解题思路2：  
这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量maxareamaxareamaxarea来持续存储到目前为止所获得的最大面积。在每一步中，我们会找出指针所指向的两条线段形成的区域，更新maxareamaxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步（参考LeetCode题解，）。话不多说，看代码：

```java
class Solution{
    public int maxArea(int[] height) {
         if(height==null || height.length<2) return 0;
         int left=0;
         int right=height.length-1;
         int maxArea=0;
         while(left<right){
         //必须先计算更新maxArea
          maxArea=Math.max(maxArea,Math.min(height[left],height[right])*(right-left));
             if(height[left]<height[right]){
                 left++;
             }
             else{
                right--; 
             }
         return maxArea;
    }
}
```





 



