# LeetCode01 两数之和
题目描述

给定一个整数数组 nums 和一个目标值
target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

![image](https://github.com/2018uestc/LeetCode_tupian/blob/master/LeetCode01.png)

解题思路：

这个题目第一眼一看首先想到的是暴力解决，采用2重循环，类似于双指针的解法，结果是可以通过的，具体代码如下：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

对于上面暴力解法，时间复杂度为O(n^2)，空间复杂度为O(1)一般在算法题里面是会超时的。如何不采用暴力解法。对于该题可以采用哈希来解决。哈希的作用就是用空间换时间。我们遍历原数组，hash里面存放的是数组中的元素和对应下标的值。遍历一遍即可，具体代码如下：

```java
class Solution{
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int complement=target-nums[i];
            if(map.containsKey(complement)){
                return new int[]{map.get(complement),i};
            }
            map.put(nums[i],i);
        }
        throw new IllegaArgumentException("没有满足条件的结果");
    }
}
```
这种解法的时间复杂度为O(n)，空间复杂度为O(n)。典型的空间换时间的算法。

# LeetCode04 寻找两个有序数组的中位数
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。  
示例 1:  
nums1 = [1, 3]
nums2 = [2]  
则中位数是 2.0  
示例 1:  
nums1 = [1, 2]
nums2 = [3,4]  
则中位数是 (2 + 3)/2 = 2.5

解题思路 
1. 第一眼看到这个题目的时候，首先想到的是将给定的2个数组合并成一个数组，然后求一个数组的中位数的，一个数组的中位数对于我们来说很熟悉。但是题目中明确要求时间复杂度为O(log(m + n))，这就给之前的那个单纯的想法判了死刑。但是同时也打开了另外一扇窗，就是这个时间复杂度很明显是二分差查找法的特征。因此想到用二分法来解决。  
1. 那么这个二分法究竟怎么来解决这个题目呢？首先我们定义nums1和nums2的长度分别为m和n，如果m+n为奇数，那么中位数为numCombination[(m+n)/2 + 1]，加1的原因是下标和第几个元素之间相差1。如果m+n为偶数，那么中位数为numCombination[(m+n)/2 + 1]+numCombination[(m+n)/2]相加除以2。以上numCombination指的是nums1和nums2合并后的数组，用作分析用。  
1. 所以本题目变成了两个有序数组A(m), B(n)，k = (m+n)/2，奇数时找k+1大的数，偶数是找第k大和第k+1大的数再除2（依然是数组中的第几个，和下标相差1）。即题目转换成了求2个有序数组中的第k大数。可以采用二分查找的方法。  
1. 找第k((m+n)/2)大的数。先在A，B中分别找第k/2大的数，如果A[k/2-1]等于B[k/2-1]，那么这个数就是两个数组中第k大的数。如果A[k/2-1]<B[k/2-1],那么说明A[0]到A[k/2-1]都不可能是第k大的数，所以需要舍弃这k/2，继续从A[k/2]到A[A.length-1]继续找。当然，因为这里舍弃了A[0]到A[k/2-1]这k/2个数，那么第k大也就变成了第k-k/2个大的数了。如果 A[k/2-1]>B[k/2-1]，那么说明B[0]到B[k/2-1]都不可能是第k大的数，舍弃这k/2。如此迭代或者递归操作，如果有一个数组为空了，则返回另一个数组的第k大(剩下需要二分长度)的数。如果k==1，只需返回此时所以数中排第一小的数，就返回此时A，B中第一个元素小的那个。代码如下：
 
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m=nums1.length;
        int n=nums2.length;
        int len=m+n;
        //奇数查len+1
        if(len%2==1){
            return findKth(nums1,0,nums2,0,len/2+1);
        }
        //偶数查
        return (findKth(nums1,0,nums2,0,len/2)+findKth(nums1,0,nums2,0,len/2+1))/2.0;
    }
    public static int findKth(int[] A, int A_start,
                              int[] B, int B_start,
                              int k){
        //A_start>= A.length，说明第k个数不在数组A当中，所以要去数组B中去找                      
        if (A_start >= A.length) {
            return B[B_start + k - 1];
        }
        //B_start>= B.length，说明第k个数不在数组B当中，所以要去数组A中去找
        if (B_start >= B.length) {
            return A[A_start + k - 1];
        }
        if (k == 1) {
            return Math.min(A[A_start], B[B_start]);
        }
         
        int A_key = A_start + k / 2 - 1 < A.length
                    ? A[A_start + k / 2 - 1]
                    : Integer.MAX_VALUE;
        int B_key = B_start + k / 2 - 1 < B.length
                    ? B[B_start + k / 2 - 1]
                    : Integer.MAX_VALUE;
         
        if (A_key < B_key) {
            return findKth(A, A_start + k / 2, B, B_start, k - k / 2);
        } else {
            return findKth(A, A_start, B, B_start + k / 2, k - k / 2);
        }
    }
}
```

 



